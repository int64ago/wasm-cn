<!DOCTYPE html>
<html>
<head>
<meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, minimum-scale=1.0, initial-scale=1.0, user-scalable=yes">
  <meta name="keywords" content="WebAssembly,wasm,ä¸­æ–‡,æ–‡æ¡£,ä¸­æ–‡æ–‡æ¡£">
  <meta name="description" content="WebAssembly ä¸­æ–‡æ–‡æ¡£">
  <title>ç‰¹æ€§æµ‹è¯• - WebAssembly</title>
  <link rel="stylesheet" type="text/css" href="/css/custom.css">
</head>


<body>
  <header class="page-section-spacious">
    <div class="container">
    <div class="site-logo">
      <h1 class="title">WebAssembly ä¸­æ–‡æ–‡æ¡£</h1>
    </div>
    <nav class="site-nav">
      <a class="site-nav-item btn" href="/">æ€»è§ˆ</a>
      <a class="site-nav-item btn" href="/demo/">å®ä¾‹</a>
      <a class="site-nav-item btn" href="/getting-started/developers-guide/">å¿«é€Ÿå¼€å§‹</a>
      
      
      <a class="site-nav-item btn" href="/docs/js/">æ–‡æ¡£</a>
      <a class="site-nav-item btn" href="/community/feedback/">ç¤¾åŒº</a>
      <a class="site-nav-item btn" href="/roadmap/">è§„åˆ’</a>
      <a class="site-nav-item btn" href="/docs/faq/">é—®ç­”</a>
      <a class="site-nav-item btn" href="https://github.com/int64ago/wasm-cn" target="_blank">ğŸ’“å‚ä¸ç¿»è¯‘ğŸ’“</a>
    </nav>
    </div>
  </header>
  <section class="banner-update">
    <div class="container">
      <div class="banner-update-icon"></div>
      <span class="banner-update-date"></span>
      <span>WebAssembly åˆç‰ˆè§„èŒƒå·²ç”±å„ä¸ªæµè§ˆå™¨å‚å•†è¾¾æˆå…±è¯†ï¼Œ<a href="/roadmap/">äº†è§£æ›´å¤š</a></span>
    </div>
  </section>
  

<section>
  <div class="container">
    <div class="row">
      <div class="col-xs-12 col-lg-9 col-pop">
        <p>See <a href="../rationale/#feature-testing---motivating-scenarios">rationale</a> for motivating scenarios.</p>

<h1 id="ç‰¹æ€§æµ‹è¯•">ç‰¹æ€§æµ‹è¯•</h1>

<p><a href="../future-features/">Post-MVP <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a>, applications will be able to query which features are
supported via
<a href="../future-features/#feature-testing"><code class="highlighter-rouge">has_feature</code> or a similar API <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a>. This
accounts for the pragmatic reality that features are shipped in different orders
at different times by different engines.</p>

<p>What follows is a sketch of what such a feature testing capability could look
like.</p>

<p>Since some WebAssembly features add operators and all WebAssembly code in a
module is validated ahead-of-time, the usual JavaScript feature detection
pattern:</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>if (foo)
    foo();
else
    alternativeToFoo();
</code></pre>
</div>

<p>wonâ€™t work in WebAssembly (if <code class="highlighter-rouge">foo</code> isnâ€™t supported, <code class="highlighter-rouge">foo()</code> will fail to
validate).</p>

<p>Instead, applications may use one of the following strategies:</p>

<ol>
  <li>
    <p>Compile several versions of a module, each assuming different feature support
and use <code class="highlighter-rouge">has_feature</code> tests to determine which version to load.</p>
  </li>
  <li>
    <p>During the <a href="../binary-encoding/">â€œspecificâ€ layer decoding</a>, which will happen
in user code in the MVP <em>anyway</em>, use <code class="highlighter-rouge">has_feature</code> to determine which features
are supported and then translate unsupported feature use into either a polyfill
or a trap.</p>
  </li>
</ol>

<p>Both of these options could be automatically provided by the toolchain and
controlled by compiler flags. Since <code class="highlighter-rouge">has_feature</code> is a constant expression,
it can be constant-folded by WebAssembly engines.</p>

<p>To illustrate, consider 4 examples:</p>

<ul>
  <li>
<a href="../future-features/#additional-integer-operators"><code class="highlighter-rouge">i32.min_s</code> <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a> - Strategy 2
could be used to translate <code class="highlighter-rouge">(i32.min_s lhs rhs)</code> into an equivalent expression
that stores <code class="highlighter-rouge">lhs</code> and <code class="highlighter-rouge">rhs</code> in locals then uses <code class="highlighter-rouge">i32.lt_s</code> and <code class="highlighter-rouge">select</code>.</li>
  <li>
<a href="../future-features/#threads">Threads <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a> - If an application uses <code class="highlighter-rouge">#ifdef</code> extensively
to produce thread-enabled/disabled builds, Strategy 1 would be appropriate.
However, if the application was able to abstract use of threading to a few
primitives, Strategy 2 could be used to patch in the right primitive 
implementation.</li>
  <li>
<a href="../future-features/#finer-grained-control-over-memory"><code class="highlighter-rouge">mprotect</code> <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a> - If engines
arenâ€™t able to use OS signal handling to implement <code class="highlighter-rouge">mprotect</code> efficiently,
<code class="highlighter-rouge">mprotect</code> may become a permanently optional feature. For uses of <code class="highlighter-rouge">mprotect</code>
that are not necessary for correctness (but rather just catching bugs),
<code class="highlighter-rouge">mprotect</code> could be replaced with <code class="highlighter-rouge">nop</code>. If <code class="highlighter-rouge">mprotect</code> was necessary for
correctness but an alternative strategy existed that did not rely on
<code class="highlighter-rouge">mprotect</code>, <code class="highlighter-rouge">mprotect</code> could be replaced with an <code class="highlighter-rouge">abort()</code> call, relying on
the application to test <code class="highlighter-rouge">(has_feature "mprotect")</code> to avoid calling the
<code class="highlighter-rouge">abort()</code>. The <code class="highlighter-rouge">has_feature</code> query could be exposed to C++ code via
the existing <code class="highlighter-rouge">__builtin_cpu_supports</code>.</li>
  <li>
<a href="../future-features/#fixed-width-simd">SIMD</a> - When SIMD operators have a good-enough
polyfill, e.g., <code class="highlighter-rouge">f32x4.fma</code> via <code class="highlighter-rouge">f32x4.mul</code>/<code class="highlighter-rouge">add</code>, Strategy 2 could be used 
(similar to the <code class="highlighter-rouge">i32.min_s</code> example above). However, when a SIMD feature has no
efficient polyfill (e.g., <code class="highlighter-rouge">f64x2</code>, which introduces both operators <em>and</em>
types), alternative algorithms need to be provided and selected at load time.</li>
</ul>

<p>As a hypothetical (not implemented) example polyfilling the SIMD <code class="highlighter-rouge">f64x2</code>
feature, the C++ compiler could provide a new function attribute that indicated
that one function was an optimized, but feature-dependent, version of another
function (similar to the
<a href="https://gcc.gnu.org/onlinedocs/gcc-4.7.2/gcc/Function-Attributes.html#index-g_t_0040code_007bifunc_007d-attribute-2529"><code class="highlighter-rouge">ifunc</code> attribute</a>,
but without the callback):</p>

<div class="highlighter-rouge">
<pre class="highlight"><code>#include &lt;xmmintrin.h&gt;
void foo(...) {
  __m128 x, y;           // -&gt; f32x4 locals
  ...
  x = _mm_add_ps(x, y);  // -&gt; f32x4.add
  ...
}
void foo_f64x2(...) __attribute__((optimizes("foo","f64x2"))) {
  __m256 x, y;           // -&gt; f64x2 locals
  ...
  x = _m_add_pd(x, y);   // -&gt; f64x2.add
  ...
}
...
foo(...);                 // calls either foo or foo_f64x2
</code></pre>
</div>

<p>In this example, the toolchain could emit both <code class="highlighter-rouge">foo</code> and <code class="highlighter-rouge">foo_f64x2</code> as
function definitions in the â€œspecific layerâ€ binary format. The load-time
polyfill would then replace <code class="highlighter-rouge">foo</code> with <code class="highlighter-rouge">foo_f64x2</code> if
<code class="highlighter-rouge">(has_feature "f64x2")</code>. Many other strategies are possible to allow finer or
coarser granularity substitution. Since this is all in userspace, the strategy
can evolve over time.</p>

<p>See also the <a href="../future-features/#feature-testing">better feature testing support <img class="emoji" title=":unicorn:" alt=":unicorn:" src="https://assets-cdn.github.com/images/icons/emoji/unicode/1f984.png" height="20" width="20" align="absmiddle"></a>
future feature.</p>


      </div>
      <div class="col-xs-12 col-lg-3">
        <h6 class="side-title">æ–‡æ¡£</h6>
        <nav class="side-nav">
        
        
          
        
          
        
          
          <a class="side-nav-item" href="/docs/js/">JavaScript API</a>
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
        
          
          <a class="side-nav-item" href="/docs/binary-encoding/">äºŒè¿›åˆ¶ç¼–ç </a>
          
        
          
          <a class="side-nav-item" href="/docs/c-and-c++/">C/C++ å¼€å‘æŒ‡å—</a>
          
        
          
        
          
          <a class="side-nav-item" href="/docs/dynamic-linking/">åŠ¨æ€é“¾æ¥</a>
          
        
          
        
          
          <a class="side-nav-item" href="/docs/faq/">é—®ç­”</a>
          
        
          
          <a class="side-nav-item" href="/docs/feature-test/">ç‰¹æ€§æµ‹è¯•</a>
          
        
          
          <a class="side-nav-item" href="/docs/future-features/">æœªæ¥æ”¯æŒç‰¹æ€§</a>
          
        
          
          <a class="side-nav-item" href="/docs/gc/">GC / DOM / Web API é›†æˆ</a>
          
        
          
          <a class="side-nav-item" href="/docs/high-level-goals/">WebAssembly æ•´ä½“ç›®æ ‡</a>
          
        
          
          <a class="side-nav-item" href="/docs/jit-library/">JIT å’Œä¼˜åŒ–</a>
          
        
          
          <a class="side-nav-item" href="/docs/mvp/">æœ€å°å¯è¡Œäº§å“</a>
          
        
          
          <a class="side-nav-item" href="/docs/modules/">æ¨¡å—</a>
          
        
          
          <a class="side-nav-item" href="/docs/non-web/">é Web ç¯å¢ƒé›†æˆ</a>
          
        
          
          <a class="side-nav-item" href="/docs/nondeterminism/">ä¸ç¡®å®šæ€§</a>
          
        
          
          <a class="side-nav-item" href="/docs/portability/">å¯ç§»æ¤æ€§</a>
          
        
          
          <a class="side-nav-item" href="/docs/rationale/">è®¾è®¡åŸç†</a>
          
        
          
          <a class="side-nav-item" href="/docs/security/">å®‰å…¨</a>
          
        
          
          <a class="side-nav-item" href="/docs/semantics/">è¯­ä¹‰</a>
          
        
          
          <a class="side-nav-item" href="/docs/text-format/">æ–‡æœ¬æ ¼å¼</a>
          
        
          
          <a class="side-nav-item" href="/docs/tooling/">å·¥å…·æ”¯æŒ</a>
          
        
          
          <a class="side-nav-item" href="/docs/use-cases/">ä½¿ç”¨åœºæ™¯</a>
          
        
          
          <a class="side-nav-item" href="/docs/web/">Web ç¯å¢ƒé›†æˆ</a>
          
        
        </nav>
      </div>
    </div>
  </div>
</section>
</body>
</html>
